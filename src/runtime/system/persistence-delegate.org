#+TITLE: Persistence Delegate for the System
#+AUTHOR: VLEAD
#+DATE: [2016-07-07 Thu]
#+SETUPFILE: ../../org-templates/level-2.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Persistence Delegate
  Persistence Delegate encapsulates a set of functions where each function performs a
  specific task.  With the use of these delegates, the core implementation of
  the =system= will not alter but by plugging delegates that are specific to
  each environment, for example, be it either objects or persistence, the
  =system= for that particular environment is derived while not modifying the
  =system= class.
  
** Initialize Persistence Delegate
   Provides all the delegates that operate on objects.

*** class_persistence_delegate 
#+NAME: class_persistence_delegate
#+BEGIN_SRC python
class PersistenceDelegate():
   
    def __init__(self):
        pass
        
#+END_SRC


*** get_role_set
#+NAME: persistent_get_role_set
#+begin_src python
    def get_role_set(self):
        return Role.get_all()

#+end_src


*** get_user_set
#+NAME: persistent_get_user_set
#+begin_src python
    def get_user_set(self):
        return User.get_all()

#+end_src


*** Tests
#+NAME: test_class_persistent_delegate
#+BEGIN_SRC python
class TestPersistentDelegate(TestCase):
    TESTING = True

    def create_app(self):
        app = create_app(config)
        return app

    def setUp(self):
        db.create_all()
        self.persistent_delegate = PersistenceDelegate()
        
    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.persistent_delegate = None

#+END_SRC


** Other functions

   Other functions that help =System= perform the operations. 
   
***  Check if =question= already exists
    This function checks if a user is already in the user-set of the =System=.
#+NAME: persistent_question_exists
#+BEGIN_SRC python
    def question_exists(self, question):
        question_name = question.get("name")
        if question_name:
            return question == self.get_question(name=question_name)
        else:
            return False

#+END_SRC

**** Tests
#+NAME: test_persistent_question_exists
#+BEGIN_SRC python
    def test_question_exists(self):
        print "test_question_exists"
        name1="how are labs?"
        radio="radio"
        question1 = Question(name=name1, question_type=radio)
        question = self.persistent_delegate.add_question(question1)

        name2="how are experiments?"
        question2 = Question(name=name2, question_type=radio)
        
        self.assertEqual(self.persistent_delegate.question_exists(question),
                            True)
        self.assertEqual(self.persistent_delegate.question_exists(question2),
                            False)

#+END_SRC


***  Check if =key= already exists
    This function checks if a key matches with the configuration key.
#+NAME: persistent_key_exists
#+BEGIN_SRC python
    def key_exists(self, key):
        if key == Config.key:
            return True
        else:
            return False

#+END_SRC

**** Tests
#+NAME: test_persistent_key_exists
#+BEGIN_SRC python
    def test_key_exists(self):
        print "test_key_exists"
        key = "some alphanumeric string" 
        self.assertEqual(self.persistent_delegate.key_exists(key), True)
        key1 = "some other string"
        self.assertEqual(self.persistent_delegate.key_exists(key1), False)

#+END_SRC


***  Add question to the system
    This function adds question to the system.
#+NAME: persistent_add_question
#+BEGIN_SRC python
    def add_question(self, question):
        question.save()
        return question

#+END_SRC

**** Tests
#+NAME: test_persistent_add_question
#+BEGIN_SRC python
    def test_add_question(self):
         print "test_add_question"
         name = "how are labs?"
         question_type = "radio"
         question = Question(name=name, question_type=question_type)
         question1 = self.persistent_delegate.add_question(question)
         self.assertEqual(self.persistent_delegate.question_exists(question1),
                          True)

#+END_SRC


***  Add answer to the system
    This function adds question to the system.
#+NAME: persistent_add_answer
#+BEGIN_SRC python
    def add_answer(self, answer):
        answer.save()
        return answer

#+END_SRC

**** Tests
#+NAME: test_persistent_add_answer
#+BEGIN_SRC python
    def test_add_answer(self):
         print "test_add_answer"
         ans = "excellent labs"
         answer = Answer(name=ans)
         answer1 = self.persistent_delegate.add_answer(answer)
         answer1 = Answer.get_by_id(1)
         self.assertEqual(answer1.get("name"), ans)

#+END_SRC


***  Add feedback to the system
    This function adds a feedback to the system.
#+NAME: persistent_add_feedback
#+BEGIN_SRC python
    def add_feedback(self, gateway_ip, lab_id, exp_id, date):
        new_feedback = Feedback(gateway_ip=gateway_ip,
                                lab_id=lab_id,
                                exp_id=exp_id,
                                date=date,
                                responses=[])
        new_feedback.save()
        return new_feedback

#+END_SRC

**** Tests
#+NAME: test_persistent_add_feedback
#+BEGIN_SRC python
    def test_add_feedback(self):
         print "test_add_feedback"
         gateway_ip = "10.100.40.2"
         lab_id = "cse01"
         exp_id = "data01"
         date = datetime.datetime.strptime("30-06-2016", "%d-%m-%Y").date()
         fb1 = self.persistent_delegate.add_feedback(gateway_ip, lab_id,
                                                        exp_id, date)
         feedback = Feedback.get_by_id(1)
         self.assertEqual(feedback.get("gateway_ip"), gateway_ip)
         self.assertEqual(feedback.get("lab_id"), lab_id)
         self.assertEqual(feedback.get("exp_id"), exp_id)
         self.assertEqual(feedback.get("responses"), [])

#+END_SRC


***  Get an object
    A generic function to find an object of type =cls= matching a given a criteria

#+NAME: persistent_get_object
#+BEGIN_SRC python
    def get_object(self, cls, **kwargs):
        ret_val = None
        try:
            ret_val = cls.apply_filters(**kwargs)[0]
        except NotFoundError as e:
            ret_val = None
        
        return ret_val

#+END_SRC
	

***  Get Question
    This function returns an question if present in the database.  If the question is
    not present, =None= type is returned.
#+NAME: persistent_get_question
#+BEGIN_SRC python
    def get_question(self, **kwargs):
        return self.get_object(Question, **kwargs)

#+END_SRC

**** Tests
#+NAME: test_persistent_get_question
#+BEGIN_SRC python
    def test_get_question(self):
         print "test_get_question"

         name="how are labs?"
         question = Question(name=name)
         question.save()

         question_obj = self.persistent_delegate.get_question(name=
                                                question.get("name"))
         self.assertEqual(question_obj.get("name"),
                              question.get("name"))

#+END_SRC



* Infra                                                         :boilerplate:

** sources
*** Imports 

#+name: imports_for_persistent_delegates
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
from runtime.persistence.entities import *
from runtime.config.config import Config
from runtime.exceptions.custom_exceptions import *
#+end_src

** Tests
*** Imports 

#+name: imports_for_tests_persistence
#+BEGIN_SRC python
# -*- coding: utf-8 -*-
import unittest
from flask_testing import TestCase
from runtime.rest.app import create_app
from runtime.system.persistent_delegates import *


config = {
         'SQLALCHEMY_DATABASE_URI': ''
         }
#+end_src


*** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python
if __name__ == '__main__':
    unittest.main()

#+END_SRC


* Tangling                                                      :boilerplate:
  
** sources
   
#+BEGIN_SRC python :tangle persistent_delegates.py :eval no :noweb yes
<<imports_for_persistent_delegates>>
<<class_persistence_delegate>>
<<persistent_key_exists>>
<<persistent_get_object>>
<<persistent_get_question>>
<<persistent_question_exists>>
<<persistent_add_question>>
<<persistent_add_answer>>
<<persistent_add_feedback>>
#+end_src

** tests
#+BEGIN_SRC python :tangle test_persistent_delegates.py :eval no :noweb yes
<<imports_for_tests_persistence>>
<<test_class_persistent_delegate>>
<<test_persistent_key_exists>>
<<tes_persistent_get_question>>
<<test_persistent_question_exists>>
<<test_persistent_add_question>>
<<test_persistent_add_answer>>
<<test_persistent_add_feedback>>
<<run_test_cases>>

#+end_src

